/* cl_rep.C */

/* this file is part of the DISCRETA project
 * University of Bayreuth, Bavaria, Germany
 * Copyright Anton Betten 1995
 */


#include <DISCRETA/discreta.h>

#ifdef SOLVABLE_TRUE

#include <DISCRETA/solvable.h>
#include <DISCRETA/lb.h>

#define MAX_NW 64

#undef TRIVIAL_AUT_CLASSES

/* 
 * CLASS_REP_OB
 */

#if TEXDOCU
INT CLASS_REP_OB::field_name(INT i, INT j, BYTE *str)
#endif
{
	BYTE *s;
	
	switch (i) {
	case 0: s = "nb_classes"; break;
	case 1: s = "base_len"; break;
	case 2: s = "base"; break;
	case 3: s = "R"; break;
	case 4: s = "stab"; break;
	case 5: s = "version"; break;
	case 6: s = "cl"; break;
	case 7: s = "eo"; break;
	default:
		return error("CLASS_REP::field_name()|i out of range");
	}
	strcpy(str, s);
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::init(FG_OP G)
#endif
{
	ZE_OP ze;
	INT i, g_i, base_len;
	
	m_il(8);
	c_obj_k(CLASS_REP_KIND);
	s_version()->m_i(100);
	s_nb_classes()->m_i(0);
	base_len = G->s_nb_ze_i();
	s_base_len()->m_i(base_len);
	s_base()->m_il_n(base_len);
	
	for (i = 0; i < base_len; i++) {
		ze = G->s_ze_i(i);
		g_i = ze->s_n0_i();
		s_base_i(i)->m_i(g_i);
		}
	
	s_R()->m_ilih(0, 0);
	s_stab()->m_il(0);
	s_cl()->m_il(0);
	s_eo()->m_il(0);
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::sprint(BYTE *s)
#endif
{
	BYTE str[512];
	
	sprintf(str, "CLASS_REP: nb_classes = %ld base_len = %ld", 
		s_nb_classes_i(), s_base_len_i());
	if (strlen(s) + strlen(str) < 200)
		strcat(s, str);
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::Print(INT f_verbose, INT f_very_verbose)
#endif
{
	BYTE str1[256], str2[256];
	INT nb_classes, nb_stab, base_len, i, j, k, a;
	
	nb_classes = s_nb_classes_i();
	base_len = s_base_len_i();
	printf("CLASS_REP: nb_classes = %ld base_len = %ld", 
		s_nb_classes_i(), s_base_len_i());
	if (f_verbose)  {
		printf("the base:\n");
		s_base()->println();
		printf("the representatives:\n");
		for (i = 0; i < nb_classes; i++) {
			printf("%ld: ", i);
			for (j = 0; j < base_len; j++) {
				a = s_R_iji(i, j);
				printf("%ld ", a);
				}
			if (s_cl()->s_obj_k() == VECTOR) {
				if (s_cl()->s_li() > 0) {
					str1[0] = 0;
					str2[0] = 0;
					s_cl_i(i)->sprint(str1);
					s_eo_i(i)->sprint(str2);
					printf(" cl = %s eo = %s", str1, str2);
					}
				}
			printf("\n");
			}
		printf("\n");
		}

	if (f_verbose) {
		printf("the stabilizer generators:\n");
		for (i = 0; i < nb_classes; i++) {
			nb_stab = s_stab_i(i)->s_hi();
			printf("%ld-th stabilizer is generated by "
				"%ld elements\n", i, nb_stab);
			if (f_very_verbose) {
				for (j = 0; j < nb_stab; j++) {
					printf("%ld: ", j);
					for (k = 0; k < base_len; k++) {
						a = s_stab_ijki(i, j, k);
						printf("%ld ", a);
						}
					printf("\n");
					}
				}
			}
		printf("\n");
		}
	
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::recalc_cl_eo(FG_OP G)
#endif
{
	INT base_im[MAX_NW];
	INT coset_rep[MAX_NW];
	PERMUTATION_OB aut, g;
	VECTOR_OB s_gen;
	SYM_OB ago;
	INT j, n, o;
	INT nb_classes, base_len, nb_gen;
	INT i, k, l;
	SYM_OP cl, eo;
	
	printf("CLASS_REP_OB::recalc_cl_eo() G = %s\n", G->s_label_s());
	fflush(stdout);
	if (s_li() < 8) {
		while (s_li() < 8)
			inc();
		s_version()->m_i(100);
		}
	l = s_nb_classes_i();
	n = G->s_n_i();
	base_len = s_base_len_i();
	((SYM_OP) G->s_ago())->copy(&ago);
	s_cl()->m_il(l);
	s_eo()->m_il(l);
	for (i = 0; i < l; i++) {
		cl = s_cl_i(i);
		eo = s_eo_i(i);

		for (k = 0; k < base_len; k++) {
			base_im[k] = s_R_iji(i, k);
			}
		G->bi2rep(base_im, coset_rep);
		G->rep2aut(coset_rep, &aut);
		aut.order(&o);
		((INTEGER_OP) eo)->m_i(o);

		/* the stabilizer (class length into cl): */
		nb_gen = s_stab_i(i)->s_hi();
		s_gen.m_il(nb_gen);
		for (j = 0; j < nb_gen; j++) {
			for (k = 0; k < base_len; k++) {
				base_im[k] = s_stab_ijki(i, j, k);
				}
			G->bi2rep(base_im, coset_rep);
			G->rep2aut(coset_rep, &g);
			g.swap((PERMUTATION_OP) s_gen.s_i(j));
			}
		/* the stabilizer generators are now in s_gen 
		 * (as permutations of degree n) */
		{
			LABRA_OB Lab;
			SYM_OB go, class_length;

			Lab.Init(n /* deg */, &s_gen, nb_gen, FALSE, FALSE);
			Lab.jerrum(FALSE);
			Lab.group_order(&go);
			/* Lab.print_group_order(); */
			ago.ganzdiv(&go, &class_length);
			class_length.swap(cl);
		}

		}
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::calc_aut_classes_using_file(FILE *fp_txt, 
	FG_OP G, INT f_v, INT f_vv)
#endif
{
	INT n, m, fs;
	BYTE str[1024];

	n = G->s_n_i();
	m = G->s_m_i();
	sprintf(str, "%ld#%ld_aut_classes.bin", n, m);
	fs = file_size(str);
	if (fs > 0) {
		if (f_v) {
			fprintf(fp_txt, "CLASS_REP::calc_aut_classes_using_file(): "
				"file %s of size %ld exists; we read it\n", 
				str, fs);
			fflush(fp_txt);
			}
		read_op_file(this, str, f_vv /* f_verbose */ , FALSE /* f_use_compress */);
		}
	else {
#ifdef TRIVIAL_AUT_CLASSES
		trivial_aut_classes(fp_txt, G, f_v, f_vv);
#else
		calc_aut_classes(fp_txt, G, f_v, f_vv);
#endif
		}
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::trivial_aut_classes(FILE *fp_txt, FG_OP G, INT f_v, INT f_vv)
#else
/* old version: does not initialize cl/eo ! */
#endif
{
	PERMUTATION_OB p;
	INT ago, i, j, k;
	INT g_j, a, nb_gen;
	INT base_len;

	init(G);
	if (G->s_ago()->s_obj_k() != INTEGER)
		return error("CLASS_REP_OB::trivial_aut_classes() aut not an INTEGER");
	ago = ((INTEGER_OP) G->s_ago())->s_i();
	s_nb_classes()->m_i(ago);
	base_len = s_base_len_i();
	
	/* initialize R: */
	if (f_vv) {
		fprintf(fp_txt, "trivial_aut_classes(): init representatives\n");
		fflush(fp_txt);
		}
	s_R()->m_ilih(base_len, ago);
	for (i = 0; i < ago; i++) {
		G->int2aut(i, &p);
		for (j = 0; j < base_len; j++) {
			g_j = s_base_ii(j);
			a = p.s_ii(g_j) - 1;
			s_R_ij(i, j)->m_i(a);
			}
		}
	if (f_vv) {
		printf("finished.\n");
		fflush(stdout);
		}
	
	/* initialize stab: */
	if (f_vv) {
		printf("init representatives\n");
		fflush(stdout);
		}
	s_stab()->m_il(ago);
	for (i = 0; i < ago; i++) {
		G->int2aut(i, &p);
		nb_gen = 0;
		s_stab_i(i)->m_ilih_n(base_len, nb_gen);
		}
		
	if (f_vv) {
		printf("finished.\n");
		fflush(stdout);

		Print(TRUE, FALSE);
		}

	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::get_aut_class_info(FG_OP G, 
	VECTOR_OP cl, VECTOR_OP eo, INT f_v)
#else
/* (class length, element order) vectors */
#endif
{
	INT base_im[MAX_NW];
	INT coset_rep[MAX_NW];
	PERMUTATION_OB aut, g;
	VECTOR_OB s_gen;
	SYM_OB ago;
	INT i1, j, n, o, k;
	INT nb_classes, base_len, nb_gen;

	if (f_v) {
		printf("get_aut_class_info() for group %s:\n", G->s_label_s());
		fflush(stdout);
		}
	if (s_li() > 5) {
		s_cl()->copy(cl);
		s_eo()->copy(eo);
		return OK;
		}
	n = G->s_n_i();
	((SYM_OP) G->s_ago())->copy(&ago);
	nb_classes = s_nb_classes_i();
	base_len = s_base_len_i();
	cl->m_il(nb_classes);
	eo->m_il(nb_classes);

	for (i1 = 0; i1 < nb_classes; i1++) {

		/* the automorphism itself (element order into eo): */
		if (f_v) {
			printf("aut-class %ld: [", i1);
			fflush(stdout);
			}
		for (k = 0; k < base_len; k++) {
			base_im[k] = s_R_iji(i1, k);
			if (f_v) {
				printf("%3ld", base_im[k]);
				if (k < base_len - 1)
					printf(", ");
				}
			}
		G->bi2rep(base_im, coset_rep);
		G->rep2aut(coset_rep, &aut);
		aut.order(&o);
		if (f_v) {
			printf("] %5ld ", o);
			}
		eo->m_ii(i1, o);

		/* the stabilizer (class length into cl): */
		nb_gen = s_stab_i(i1)->s_hi();
		if (f_v) {
			printf("nb_gen = %ld ", nb_gen);
			fflush(stdout);
			}
		s_gen.m_il(nb_gen);
		for (j = 0; j < nb_gen; j++) {
			for (k = 0; k < base_len; k++) {
				base_im[k] = s_stab_ijki(i1, j, k);
				}
			G->bi2rep(base_im, coset_rep);
			G->rep2aut(coset_rep, &g);
			g.swap((PERMUTATION_OP) s_gen.s_i(j));
			}
		/* the stabilizer generators are now in s_gen 
		 * (as permutations of degree n) */
		{
			LABRA_OB Lab;
			SYM_OB go, class_length;

			Lab.Init(n /* deg */, &s_gen, nb_gen, FALSE, FALSE);
			Lab.jerrum(FALSE);
			Lab.group_order(&go);
			/* Lab.print_group_order(); */
			ago.ganzdiv(&go, &class_length);
			if (f_v) {
				printf("class_length = ");
				class_length.println();
				fflush(stdout);
				}
			class_length.swap(cl->s_i(i1));
		}
		}
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::get_aci_ordered(FG_OP G, 
	VECTOR_OP val, VECTOR_OP mult, INT f_v, INT f_vv)
#endif
{
	VECTOR_OB cl, eo;
	VECTOR_OB type;

	if (f_v) {
		printf("aut-classes of group %s:\n", G->s_label_s());
		fflush(stdout);
		}
	get_aut_class_info(G, &cl, &eo, f_vv);

	type.join2(&cl, &eo);
	if (f_v) {
		printf("type=");
		type.println();
		fflush(stdout);
		}
	type.multiplicities(val, mult);
	if (f_v) {
		printf("val=");
		val->println();
		fflush(stdout);
		printf("mult=");
		mult->println();
		fflush(stdout);
		}
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::sprint_aut_class_structure(FG_OP G, 
	BYTE *str, INT f_v, INT f_vv)
#endif
{
	VECTOR_OB val, mult;

	if (f_v) {
		printf("aut-classes of group %s:\n", G->s_label_s());
		fflush(stdout);
		}
	get_aci_ordered(G, &val, &mult, f_v, f_vv);
	val.sprint_multiplicities(&mult, str);
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::prepare_aut_class_info(FG_OP G, VECTOR_OP V)
#endif
{
	VECTOR_OB val, mult;
	VECTOR_OP key;
	STRING_OP s;
	INT i, l, m /* , cl, eo */;
	INT f_v = FALSE;
	BYTE str[256], cl_str[256], eo_str[256];

	if (f_v) {
		printf("aut-classes of group %s:\n", G->s_label_s());
		fflush(stdout);
		}
	get_aci_ordered(G, &val, &mult, FALSE, FALSE);
	l = val.s_li();
	V->m_il(l);
	for (i = 0; i < l; i++) {
		key = (VECTOR_OP) val.s_i(i);
		m = mult.s_ii(i);
		cl_str[0] = 0;
		eo_str[0] = 0;
		key->s_i(0)->sprint(cl_str);
		key->s_i(1)->sprint(eo_str);
		/* cl = key->s_ii(0);
		eo = key->s_ii(1); */
		sprintf(str, "%ld x %s/%s", m, cl_str, eo_str);
		if (i < l - 1)
			strcat(str, ", ");
		s = (STRING_OP) V->s_i(i);
		s->init(str);
		}
	return OK;
}

#if TEXDOCU
INT CLASS_REP_OB::calc_aut_classes(FILE *fp_txt, FG_OP G, INT f_v, INT f_vv)
#endif
{
	return error("CLASS_REP_OB::calc_aut_classes not yet implemented");
}

#endif /* SOLVABLE_TRUE */

