/* mindist.C */

/* this file is part of the DISCRETA project
 * University of Bayreuth, Bavaria, Germany
 * Copyright Anton Betten 1997
 */

#include <DISCRETA/discreta.h>
#include <DISCRETA/codes.h>

#include <stdlib.h>

typedef struct mindist MINDIST;

#if TEXDOCU
#else
The algorithm for computing the minimum distance implemented here 
is due to Brouwer. It has been described in 
Betten, Fripertinger et al.~\cite{BettenCodes98}.
#endif

#if TEXDOCU
struct mindist {
	int f_v, f_vv;
	int k, n, d, q;
	int p, f;
	int **G;
	int ***S;
	int M;
	int K0;
	int ZC;
	int *Size;
	int *ff_mult; // [q][q]
	int *ff_add; // [q][q]
	int *ff_inv; // [q]
	int idx_zero;
	int idx_one;
	int idx_mone;
};
#else
Local data structure for the mindist computation.
Contains tables for the finite field structure.
#endif

static void print_matrix(MINDIST *MD, int **G);
static int min_weight(MINDIST *MD);
static void create_systematic_generator_matrices(MINDIST *MD);
static int weight_of_linear_combinations(MINDIST *MD, int t);
static int weight(int *v, int n, int idx_zero);
static void padic(int ind, int *v, int L, int A);
static int nextsub(int k, int l, int *sub);
static void vmmult(MINDIST *MD, int *v, int **mx, int *cv);


#if TEXDOCU
INT code_Mindist_of_matrix(MATRIX_OP G, INT q)
#else
Compute minimum distance of code generated by the matrix G.
The elements are over $GF(q)$.
$q$ can be a real extension field (of some $GF(p)$ say).
In that case, the elements must be in the numeric labelling.
In the case of $GF(p)$, the elements must be in $\{0,1,\ldots,p-1\}$.
#endif
{
	ZECH_DATA *Z;
	INT i, j, n, k;
	INT p, f;
	int *g;
	VECTOR_OB vp, ve;
	INT f_v = FALSE;
	INT f_vv = FALSE;
	int d;

	factor_integer(q, &vp, &ve);
	if (vp.s_li() > 1) {
		error("code_Mindist_of_matrix() q not a prime-power");
		exit(1);
		}
	p = vp.s_ii(0);
	f = ve.s_ii(0);
	if (f > 1) {
		Z = zech_open(p, f, f_v);
		}
	else
		Z = NIL;
	
	n = G->s_li();
	k = G->s_hi();
	g = (int *) my_malloc(sizeof(INT) * k * n, "code_Mindist_of_matrix");
	for (i = 0; i < k; i++) {
		for (j = 0; j < n; j++) {
			g[i * n + j] = G->s_iji(i, j);
			}
		}
	// get the permutation representation
	// (and the Zech tables if q is a prime power with f > 1)
	mindist((int) n, (int) k, (int) q, &d, g, (int) f_v, (int) f_vv, 0, 1, Z);
	my_free(g);
	if (f > 1)
		zech_free(Z);
	return d;
}

#if TEXDOCU
INT code_Mindist_of_map(INT n, INT k, INT q, VECTOR_OP gamma)
#else
Mindist of a code seen as a map into projective space.
The numbering of projective elements (one-dimensional 
subspaces) is that defined be the according PERM\_REP 
data structure.
This function opens the PERM\_REP data structure and calls 
code\_mindist\_of\_map().
#endif
{
	PERM_REP *P;
	INT d, l, i;
	INT *g;
	
	l = gamma->s_li();
	g = (INT *) my_malloc(sizeof(INT) * l, "code_Mindist_of_map");
	for (i = 0; i < l; i++) {
		g[i] = gamma->s_ii(i);
		}
	// get the permutation representation
	// (and the Zech tables if q is a prime power with f > 1)
	P = open_perm_rep(q, FALSE /* f_affine */, k, FALSE /* f_verbose */);
	d = code_mindist_of_map(n, k, q, g, P);
	perm_rep_free(P);
	my_free(g);
	return d;
}

#define GFQ_CODES_MAX_DIM 100

#if TEXDOCU
INT code_mindist_of_map(INT n, INT k, INT q, INT *gamma, PERM_REP *P)
#else
#endif
{
   	INT vec1[GFQ_CODES_MAX_DIM];
	INT i, j;
	int *G;
	int d;
	int f_v = FALSE;
	int f_vv = FALSE;
	
	G = (int *) my_malloc(sizeof(int) * k * n, "code_mindist_of_map");
	for (j = 0; j < n; j++) {
		perm_rep_i2vec(P, gamma[j], vec1);
		for (i = 0; i < k; i++) {
			G[i * n + j] = (int) vec1[i];
			}
		}
	mindist((int) n, (int) k, (int) q, &d, G, 
		f_v, f_vv, P->idx_zero, P->idx_one, P->Z);
	my_free(G);
	return d;
}


#if TEXDOCU
int mindist(int n, int k, int q, int *d, int *G, 
	int f_v, int f_vv, int idx_zero, int idx_one, ZECH_DATA *Z)
#else
Main routine for the code minimum distance computation.
The ZECH\_DATA data structure is only needed if $q = p^f$ 
with $f > 1$. Otherwise, namely in the $GF(p)$ case, Z is not needed 
(pass a NIL pointer). 
#endif
{
	MINDIST MD;
	INT i, j, a;
	VECTOR_OB vp, ve;

	factor_integer(q, &vp, &ve);
	if (vp.s_li() > 1) {
		error("mindist() q not a prime-power");
		exit(1);
		}
	MD.f_v = f_v;
	MD.f_vv = f_vv;
	MD.k = k;
	MD.n = n;
	MD.q = q;
	MD.p = vp.s_ii(0);
	MD.f = ve.s_ii(0);
	MD.idx_zero = idx_zero;
	MD.idx_one = idx_one;
	MD.ff_mult = (int *) malloc(sizeof(int) * q * q);
	MD.ff_add = (int *) malloc(sizeof(int) * q * q);
	MD.ff_inv = (int *) malloc(sizeof(int) * q);
	if (MD.f > 1) {
		if (f_v) {
			printf("multiplication table:\n");
			}
		for (i = 0; i < q; i++) {
			for (j = 0; j < q; j++) {
				a = z_mult_num(Z, i, j);
				MD.ff_mult[i * q + j] = a;
				if (a == idx_one)  {
					MD.ff_inv[i] = j;
					if (i == j) 
						MD.idx_mone = i;
					}
				if (f_v) {
					printf("%d ", a);
					}
				}
			if (f_v) {
				printf("\n");
				}
			
			}
		if (f_v) {
			printf("addition table:\n");
			}
		for (i = 0; i < q; i++) {
			for (j = 0; j < q; j++) {
				a = z_add_num(Z, i, j);
				MD.ff_add[i * q + j] = a;
				if (f_v) {
					printf("%d ", a);
					}
				}
			if (f_v) {
				printf("\n");
				}
			}
		}
	else {
		if (f_v) {
			printf("multiplication table:\n");
			}
		for (i = 0; i < q; i++) {
			for (j = 0; j < q; j++) {
				a = (i * j) % q;
				MD.ff_mult[i * q + j] = a;
				if (a == idx_one) {
					MD.ff_inv[i] = j;
					if (i == j) 
						MD.idx_mone = i;
					}
				if (f_v) {
					printf("%d ", a);
					}
				}
			if (f_v) {
				printf("\n");
				}
			}
		if (f_v) {
			printf("addition table:\n");
			}
		for (i = 0; i < q; i++) {
			for (j = 0; j < q; j++) {
				a = (i + j) % q;
				MD.ff_add[i * q + j] = a;
				if (f_v) {
					printf("%d ", a);
					}
				}
			if (f_v) {
				printf("\n");
				}
			}
		}
	if (f_v) {
		printf("the field: GF(%d) = GF(%d^%d), idx_zero = %d, idx_one = %d, idx_mone = %d\n", 
			MD.q, MD.p, MD.f, MD.idx_zero, MD.idx_one, MD.idx_mone);
		}

	if (MD.idx_zero != 0) {
		printf("at the moment, we assume that idx_zero == 0\n");
		fflush(stdout);
		exit(1);
		}
	
	MD.G = (int **) malloc((sizeof (int *))*(k+2));
	for (i = 1; i <= k; i++) {
		MD.G[i] = (int *)calloc(n+2,sizeof(int));
		}

	for (i = 1; i <= k; i++) {
		for (j = 1; j <= n; j++) {
			a = G[(i-1)*n + j - 1];
			MD.G[i][j] = a;
			}
		}
	if (f_v) {
		printf("mindist(): [%ld,%ld] generator matrix over GF(%ld):\n", n, k, q);
		print_matrix(&MD, MD.G);
		}

	MD.ZC = 0;
	*d = min_weight(&MD);


	
	for (i = 1; i <= k; i++) {
		free(MD.G[i]);
		}
	free(MD.G);
	free(MD.ff_mult);
	free(MD.ff_add);
	free(MD.ff_inv);
	
	return OK;
}

#if TEXDOCU
static void print_matrix(MINDIST *MD, int **G)
#else
#endif
{
	INT i, j, a;

	for (i = 1; i <= MD->k; i++) {
		for (j = 1; j <= MD->n; j++) {
			a = G[i][j];
			printf("%ld ", a);
			}
		printf("\n");
		}
	
}


#if TEXDOCU
static int min_weight(MINDIST *MD)
#else
calculate minimum-weight of code created by generatormatrix G.
Main routine, loop with the two bounds (upper and lower) 
for the minimum distance. 
See Kerber / Zimmerman for a description of the algorithm. 
#endif
{
	int n = MD->n;
	int k = MD->k;
 int i,j,t;
	int a, b;
 int w_c,w_t,w_r; /* minimum-weight of code /regarded /not regarded codevectors */
 int size = 0; /* number of information subsets */
	
	/* allocate base pointer for the (k,n)-generator matrices */
	MD->S = (int ***)malloc((sizeof (int **))*(n+2));
	create_systematic_generator_matrices(MD);

	/* evaluate minimum weight of code created by generator matrix G */
	for (i=1;i<=MD->M;i++)
		size = size + MD->Size[i];
	w_c = n;
	w_r = 0;
	t = 0;
	while (w_c > w_r && t < k) {
		t = t+1;
		
		/* evaluate minimumweight of codevectors created by linearcombination
		   of t rows of the systematic generator matrices S[1],...,S[M] */
		w_t = weight_of_linear_combinations(MD, t); 
		if (MD->f_v) {
			printf("mindist(C_%d)=%d\n", t, w_t);
			}
		w_c = MINIMUM(w_c,w_t);
		if (MD->f_v) {
			printf("mindist(C_{\\le %d})=%d\n", t, w_c);
			}
		
		w_r = 0;
		for (i = 1; i <= MD->M; i++) {
			a = k - MD->Size[i];
			b = t + 1 - a;
			if (b > 0)
				w_r += b;
			}
		if (MD->f_v) {
			printf("w_r = %d\n", w_r);
			}

	} /* while */
	
	for (i=1;i<=MD->M;i++){
		for(j=1;j<=k;j++)
			free(MD->S[i][j]);
		free(MD->S[i]);
	}
	free(MD->S);
	free(MD->Size);
	return(w_c);
}


#if TEXDOCU
static void create_systematic_generator_matrices(MINDIST *MD)
#else
create systematic generator matrices
$(S[1]=(I,*),...,S[z]=(*,I,*),...,S[M]=(*,I))$
with identity-matrix $I$ beginning at $P+1 = k*(z-1)+1$
(k = \# lines, m = \# systematic generator matrices),
by elementary row-transformations and permutations in
generator matrix G
//PRE
allocates S[u] for $1 \le u \le M$,
allocates S[u][i] for $1 \le u \le M, 1 \le i \le k$,
allocates Size
///PRE
#endif

{
	int n = MD->n;
	int k = MD->k;
	int q = MD->q;
	
int i,I,j,J,l;
int P, h, h1, h2, h3, pivot, pivot_inv;
int K;
int M;

	/* allocate memory for systematic generator matrix S[1] */
	MD->S[1] = (int **)calloc(k+2,sizeof(int *));
		for (i=1;i<=k;i++)
			MD->S[1][i] = (int *)calloc(n+2,sizeof(int));

	/* S[1] :=  G */
	for (i=1;i<=k;i++) 
		for (j=1;j<=n;j++)
				MD->S[1][i][j] = MD->G[i][j];
	/* allocate memory for size of information subsets of S[1] */
	MD->Size = (int *)calloc(n+1,sizeof(int ));

	M = 1;
	P = 0;
	K = k;

	while (1) {
		if (MD->f_vv) {
			printf("loop with M = %d, P = %d K = %d\n",M, P, K);
			}

		/*        create identity matrix, columns P+1,...,P+k          */

		for (i=1;i<=K;i++) {
			if (MD->f_vv) {
				printf("i = %d ", i);
				printf(" (M = %d, P = %d K = %d)\n",M, P, K);
				fflush(stdout);
				}
			/* search for pivot: 
		    	        if the entry is 0 at (i,P+i),
				    first check the entries below
				    (-> row-permutation necessary)
				    then check the columns behind  
				    (-> column-permutation necessary)    */
			/* printf("i=%d, P=%d, S[M][i][P+i]=%d\n",i,P,S[M][i][P+i]); /* */
			for (J=P+i;J<=n;J++) {
				for (I = i; I <= K; I++) {
					if (MD->S[M][I][J] != MD->idx_zero)
						break;
					}
				if (I <= K) /* pivot found ? */
					break;
			} // next J
			if (MD->f_vv) {
				printf("I=%d, J=%d\n",I,J); fflush(stdout);
				}
			
			/*   if pivot found but end of columns reached: */
			if ((I <= K) && (J == n)) {
				if (MD->f_vv) {
					printf("end reached, I = %d\n",I);
					}
				if (P+K >= n)
					K = n - P;
			}
			if (MD->f_vv) {
				printf("pivot in I=%d J=%d\n", I, J);
				fflush(stdout);
				}

			/*   if there doesn't exist a pivot: */
			/*   P(s,t)=0 for s>=i and t>=P+i */
			if (I > K && J > n) {
				K = i-1; /* */
				if (MD->f_vv) {
					printf("no pivot\n");
					fflush(stdout);
					}
				break;
			}

			/*   if necessary: row-permutation i<->I         */
			if (I != i) {
				if (MD->f_vv) {
					printf("\nZeilentausch: %d<->%d\n",i,I);
					fflush(stdout);
					}
				for (j=1;j<=n;j++) {
					h = MD->S[M][i][j];
					MD->S[M][i][j] = MD->S[M][I][j];
					MD->S[M][I][j] = h;
				}
			}

			/*    if necessary: column-permutation P+i<->J   */
			if (J != P+i) {
				if (MD->f_vv) {
					printf("\nSpaltentausch: %d<->%d\n",P+i,J);
					fflush(stdout);
					}
				for (j=1;j<=k;j++) {
					h = MD->S[M][j][i+P];
					MD->S[M][j][i+P] = MD->S[M][j][J];
					MD->S[M][j][J] = h;
				}
			}
		
			pivot = MD->S[M][i][P + i];
			if (pivot == MD->idx_zero) {
				printf("pivot is 0, exiting!\n");
				exit(1);
				}
			pivot_inv = MD->ff_inv[pivot];
			if (MD->f_vv) {
				printf("pivot = %d, pivot_inv = %d\n", pivot, pivot_inv);
				fflush(stdout);
				}
			/* replace pivot by 1 [multiply pivot-row by inv(pivot)] */
			if (MD->S[M][i][P+i] != MD->idx_one) {
				for (j=1;j<=n;j++) {
					MD->S[M][i][j] = MD->ff_mult[MD->S[M][i][j] * q +  pivot_inv];
					}
				}
			if (MD->f_vv) {
				printf("pivot row normalized\n");
				fflush(stdout);
				}

			/* replace all elements of pivot-column, except pivot
				element, by 0 by elementary row-trans. */	 
			for (l=1;l<=k;l++) {
				if (l != i) {
					if ((h = MD->S[M][l][i+P]) != MD->idx_zero)
					for (j=1;j<=n;j++) {
						h1 = MD->ff_mult[MD->S[M][i][j] * q + h];
						h2 = MD->ff_mult[h1 * q + MD->idx_mone];
						h3 = MD->ff_add[MD->S[M][l][j] * q + h2];
						MD->S[M][l][j] = h3;


#if 0
						MD->S[M][l][j] = 
						mod_p(MD->S[M][l][j] - MD->S[M][i][j] * h);
#endif
					} // next j
				} /* if */
			} /* l */
			if (MD->f_vv) {
				printf("pivot col normalized\n");
				fflush(stdout);
				}

		} /* i */

		if (MD->f_vv) {
			printf("\nsystematic generator matrix s[%d]:\n",M);
			print_matrix(MD, MD->S[M]);
			printf("K = %d\n",K);
			}
		MD->Size[M] = K;

		if (K == 0) {
			if (MD->f_vv) {
				printf("K = 0, the generator matrix has %ld zero columns\n", n - P);
				}
			}
		if (P+K >= n || K == 0) {
			if (K == 0)
				MD->ZC = n - P; /* number of zero columns in G */
			break;
		}
		else
			P = P + K;

		M++;
		/*        find first column P+1      */ 
		MD->S[M] = (int **)calloc(k+2,sizeof(int *));
			for (i=1;i<=k;i++)
				MD->S[M][i] = (int *)calloc(n+2,sizeof(int));
		/*   S[M] :=  S[M-1] */
		for (i=1;i<=k;i++) 
			for (j=1;j<=n;j++)
				MD->S[M][i][j] = MD->S[M-1][i][j];
	} /* infinite loop */
	if (MD->f_vv) {
		printf("M = %ld\n", M);
		printf("ZC = %d\n", MD->ZC);
		printf("size of information subsets (r_i):\n");
		for (i = 1; i <= M; i++) {
			printf("%d ", MD->Size[i]);
			}
		printf("\n");
		}
	MD->M = M;

}

#if TEXDOCU
static int weight_of_linear_combinations(MINDIST *MD, int l)
#else
evaluate minimum-weight of all codevectors that are constructed
by linearcombinations of $l$ rows of matrix $S[1],...,S[M]$
algorithm: create all possibilities for combining $l$ rows out of $k$
possible matrix rows by constructing the $l$-element-
subsets over $\{1,...,k\}$;
create all possibilities for filling an $l$-element-subset by
$\{1,...,p\}$ while construct the p-adic numbers of $0,...,lc$
($lc$ = number of possibilities for filling);
combining the two results gives all possibilities of linear-
combinations of $l$ matrix-rows;
out of this construct the codevectors and
calculate minimumweight
$l$ = \# rows taken for linearcombination
// needed: weight(int *p, n, idx\_zero)
#endif
{
	int n = MD->n;
	int k = MD->k;
	int q = MD->q;
	int M = MD->M;
	int d1;
int d_l;		     /* minimum-weight by combining l rows       */  
int lc, dec, h;
int i, j, z;
int *v,*linc,*lcv;
	int *sub;
	
	/* for l = 1 the weight of a multiple of a generating codevector 
		    is equal to the weight of that codevector (p = prim) */

	/* allocate array for l-subset of a k-set */
	sub = (int *)calloc(k+1,sizeof (int));

	d_l = n;
	if (l == 1) {
		for (i=1;i<=k;i++) {
			for (z=1;z<=M;z++) {
				if (MD->Size[z] > 0) {
					d1 = weight(MD->S[z][i], n, MD->idx_zero);
					if (d1 > 0) {
						d_l = MINIMUM(d_l,d1);
					}
				} // if
			} // next z
		} // next i
		free(sub);
		return(d_l);
	}
	
	/*          construct codevectors by linear combinations of l rows
	            of the generator matrices and calculate their weight */
	else {
		/* allocate memory for help-pointers */
		v = (int*)calloc(l+2,sizeof(int)); 
		linc = (int*)calloc(k+2,sizeof(int)); 
		lcv = (int*)calloc(n+2,sizeof(int));

		lc = i_power_j(q-1, l);
#if 0
		lc = expo(p-1,l);   	/* number of possibilities to replace one 
				     	/* subset with entries 1,...,p-1 */
#endif

		/* If the l-subset is b_1,...,b_l, then form the
		   linear combination of the rows b_i times v[i] */
		for (dec = 1; dec <= lc; dec++) {
			padic(dec, v, l, q-1);

			/* for each systematic-generator-matrix S[z] */
			for (z=1;z<=M;z++) { 
				int K = MD->Size[z];
				if (K<l)
					continue;

				/* initialize with set: 1,2,...,l */
				for (i=1;i<=l;i++) 
					sub[i] = i;
				/* for (i=1;i<=l;i++) 
					printf("%d ",sub[i]); printf("\n"); /* */

				do {
				/* for (i=1;i<=l;i++) printf("%d ",sub[i]); /* */
				h = 1;
				for (j=1;j<=K;j++) {
					if (j == sub[h]) {
						linc[j] = v[h-1]+1; 
						if (h != l)
							h = h+1;
					} /* if */
					else
						linc[j] = 0;
				} /* j */
				/* construct the corresponding codevector lcv */
				vmmult(MD, linc, MD->S[z], lcv);
				/* calculate its weight and store if minimal */
				d_l = MINIMUM(d_l,weight(lcv, n, MD->idx_zero));
				} while (nextsub(K,l,sub));  /* next l-subset of K-set */
			} /* z */
		} /* dec */
		free(v);
		free(linc);
		free(lcv); 
		free(sub);
		return(d_l);
	} /* else */
	
}

#if TEXDOCU
static int weight(int *v, int n, int idx_zero)
#else
/* calculate weight of vector v ( = number or non-zero elements of v ) */
Note that in any case, 0 stands for the zero element of the field 
(either $GF(p)$ or $GF(q)$).
#endif
{
	int i,w=0;
	
	for (i=1;i<=n;i++)
		if (v[i] != idx_zero)
			w++;
	return(w);
}

#if TEXDOCU
static void padic(int ind, int *v, int L, int A)
#else
/* convert ind of radix 10 to a L digit number of radix A, and store it at v */
#endif
{
int i;
int z = ind;
/*	printf("\nv="); 		 /* Test-print */
	for (i=0; i<L;i++) {
		v[i] = z % A;
		z = (z - v[i]) / A;
/*	 	printf(" %d",v[i]);	 /* Test-print */
	}
}


#if TEXDOCU
static int nextsub(int k, int l, int *sub) 
#else
/* return 0 if lexicographically largest subset  reached, otherwise 1 */
#endif
{
int a,i,j;
	if (sub[l] != k) {
		sub[l]++;
		return 1;
	}
	else {
		i=1;
		while (i < l && sub[l-i] == k-i)
			i++;
		if (i < l) {
			a = sub[l-i];
			for (j=l-i;j<=l;j++)
				sub[j]= a + 1 + j - (l-i);
			return 1;
		}
		else {
			return 0;
		}
	}
}



#if TEXDOCU
static void vmmult(MINDIST *MD, int *v, int **mx, int *cv)
#else
/* multiply vector v with matrix mx and store it at cv */
#endif
{
	int k = MD->k;
	int q = MD->q;
	int i, j;
	int h1, h2;
	
	for (j=1; j<=MD->n; j++){
		cv[j] = 0;
		for (i=1; i<=k; i++) {
			h1 = MD->ff_mult[v[i] * q + mx[i][j]];
			h2 = MD->ff_add[cv[j] * q + h1];
			cv[j] = h2;
			// cv[j] = mod_p(cv[j] + v[i] * mx[i][j]);
			}
	}
}


